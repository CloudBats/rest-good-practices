{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 This project is a simplified list of rules for good REST API design. There are many exhaustive resources online about HTTP and REST APIs, this project doesn\u2019t intend to become that. This site\u2019s content isn\u2019t inspired from its author\u2019s opinions, but from both open and closed source publications, such as: websites: freeCodeCamp article , single page, covers the basics well Microsoft Azure Architecture article , single page, high quality content, experienced audience Mozilla HTTP Reference , well-structured, very comprehensive, mostly for reference, not for reading end-to-end books: REST API Design Rulebook , highly recommended, concise, good for any experience level Hands-On RESTful API Design Patterns and Best Practices , comprehensive, academic approach, covers advanced concepts in later chapters This project has no affiliation with the authors mentioned above.","title":"Introduction"},{"location":"#introduction","text":"This project is a simplified list of rules for good REST API design. There are many exhaustive resources online about HTTP and REST APIs, this project doesn\u2019t intend to become that. This site\u2019s content isn\u2019t inspired from its author\u2019s opinions, but from both open and closed source publications, such as: websites: freeCodeCamp article , single page, covers the basics well Microsoft Azure Architecture article , single page, high quality content, experienced audience Mozilla HTTP Reference , well-structured, very comprehensive, mostly for reference, not for reading end-to-end books: REST API Design Rulebook , highly recommended, concise, good for any experience level Hands-On RESTful API Design Patterns and Best Practices , comprehensive, academic approach, covers advanced concepts in later chapters This project has no affiliation with the authors mentioned above.","title":"Introduction"},{"location":"headers/","text":"Headers \u00b6 Todo add content Stores must support conditional PUT requests \u00b6 A store resource uses the PUT method for both insert and update, which means it is difficult for a REST API to know the true intent of a client\u2019s PUT request. Through headers, HTTP provides the necessary support to help an API resolve any potential ambiguity. A REST API must rely on the client to include the If-Unmodified-Since and/ or If-Match request headers to express their intent. The If-Unmodified-Since request header asks the API to proceed with the operation if, and only if, the resource\u2019s state representation hasn\u2019t changed since the time indicated by the header\u2019s supplied timestamp value. The If-Match header\u2019s value is an entity tag, which the client remembers from an earlier response\u2019s ETag header value. The If-Match header makes the request conditional, based upon an exact match of the header\u2019s supplied entity tag value and the representational state\u2019s current entity tag value, as stored or computed by the REST API. The following example illustrates how a REST API can support conditional PUT requests using these two headers. Two client programs, client#1 and client#2, use a REST API\u2019s /objects store resource to share some information between them. Client#1 sends a PUT request in order to store some new data that it identifies with a URI path of /objects/2113. This is a new URI that the REST API has never seen before, meaning that it does not map to any previously stored resource. Therefore, the REST API interprets the request as an insert and creates a new resource based on the client\u2019s provided state representation and then it returns a 201 (\u201cCreated\u201d) response. Some time later, client#2 decides to share some data and it requests the exact same storage URI (/objects/2113). Now the REST API is able to map this URI to an existing resource, which makes it unclear about the client request\u2019s intent. The REST API has not been given enough information to decide whether or not it should overwrite client#1\u2019s stored resource state with the new data from client#2. In this scenario, the API is forced to return a 409 (\u201cConflict\u201d) response to client#2\u2019s request. The API should also provide some additional information about the error in the response\u2019s body. If client#2 decides to update the stored data, it may retry its request to include the IfMatch header. However, if the supplied header value does not match the current entity tag value, the REST API must return error code 412 (\u201cPrecondition Failed\u201d). If the supplied condition does match, the REST API must update the stored resource\u2019s state, and return a 200 (\u201cOK\u201d) or 204 (\u201cNo Content\u201d) response. If the response does include an updated representation of the resource\u2019s state, the API must include values for the Last-Modified and ETag headers that reflect the update. HTTP supports conditional requests with the GET, POST, and DELETE methods in the same fashion that is illustrated by the example above. This pattern is the key that allows writable REST APIs to support collaboration between their clients. Location must be used to specify the URI of a newly created resource \u00b6 The Location response header\u2019s value is a URI that identifies a resource that may be of interest to the client. In response to the successful creation of a resource within a collection or store, a REST API must include the Location header to designate the URI of the newly created resource. In a 202 ( Accepted ) response, this header may be used to direct clients to the operational status of an asynchronous controller resource.","title":"Headers"},{"location":"headers/#headers","text":"Todo add content","title":"Headers"},{"location":"headers/#stores-must-support-conditional-put-requests","text":"A store resource uses the PUT method for both insert and update, which means it is difficult for a REST API to know the true intent of a client\u2019s PUT request. Through headers, HTTP provides the necessary support to help an API resolve any potential ambiguity. A REST API must rely on the client to include the If-Unmodified-Since and/ or If-Match request headers to express their intent. The If-Unmodified-Since request header asks the API to proceed with the operation if, and only if, the resource\u2019s state representation hasn\u2019t changed since the time indicated by the header\u2019s supplied timestamp value. The If-Match header\u2019s value is an entity tag, which the client remembers from an earlier response\u2019s ETag header value. The If-Match header makes the request conditional, based upon an exact match of the header\u2019s supplied entity tag value and the representational state\u2019s current entity tag value, as stored or computed by the REST API. The following example illustrates how a REST API can support conditional PUT requests using these two headers. Two client programs, client#1 and client#2, use a REST API\u2019s /objects store resource to share some information between them. Client#1 sends a PUT request in order to store some new data that it identifies with a URI path of /objects/2113. This is a new URI that the REST API has never seen before, meaning that it does not map to any previously stored resource. Therefore, the REST API interprets the request as an insert and creates a new resource based on the client\u2019s provided state representation and then it returns a 201 (\u201cCreated\u201d) response. Some time later, client#2 decides to share some data and it requests the exact same storage URI (/objects/2113). Now the REST API is able to map this URI to an existing resource, which makes it unclear about the client request\u2019s intent. The REST API has not been given enough information to decide whether or not it should overwrite client#1\u2019s stored resource state with the new data from client#2. In this scenario, the API is forced to return a 409 (\u201cConflict\u201d) response to client#2\u2019s request. The API should also provide some additional information about the error in the response\u2019s body. If client#2 decides to update the stored data, it may retry its request to include the IfMatch header. However, if the supplied header value does not match the current entity tag value, the REST API must return error code 412 (\u201cPrecondition Failed\u201d). If the supplied condition does match, the REST API must update the stored resource\u2019s state, and return a 200 (\u201cOK\u201d) or 204 (\u201cNo Content\u201d) response. If the response does include an updated representation of the resource\u2019s state, the API must include values for the Last-Modified and ETag headers that reflect the update. HTTP supports conditional requests with the GET, POST, and DELETE methods in the same fashion that is illustrated by the example above. This pattern is the key that allows writable REST APIs to support collaboration between their clients.","title":"Stores must support conditional PUT requests"},{"location":"headers/#location-must-be-used-to-specify-the-uri-of-a-newly-created-resource","text":"The Location response header\u2019s value is a URI that identifies a resource that may be of interest to the client. In response to the successful creation of a resource within a collection or store, a REST API must include the Location header to designate the URI of the newly created resource. In a 202 ( Accepted ) response, this header may be used to direct clients to the operational status of an asynchronous controller resource.","title":"Location must be used to specify the URI of a newly created resource"},{"location":"message-body/","text":"Message Body \u00b6 Todo add content","title":"Message Body"},{"location":"message-body/#message-body","text":"Todo add content","title":"Message Body"},{"location":"request-methods/","text":"Request Methods \u00b6 Definitions \u00b6 Each HTTP method is defined within the REST API resource model : GET retrieve a representation of a resource\u2019s state HEAD retrieve the metadata associated with the resource\u2019s state PUT add a new resource to a store or update a resource DELETE remove a resource from its parent POST create a new resource within a collection and execute controllers Rules \u00b6 Don\u2019t use GET and POST instead of other request methods \u00b6 Do\u2026 use HTTP methods as specified in this section Don\u2019t\u2026 change message intent and undermine the protocol\u2019s transparency compromise REST API design by misusing HTTP request methods because clients have limited HTTP vocabulary Use GET to retrieve a representation of a resource \u00b6 Do\u2026 (optional) include headers in the request ensure idempotency i.e., repeatability without side effects (especially for caching) include a body in the response Don\u2019t\u2026 include a body in the request Use HEAD to retrieve response headers without a body \u00b6 Use HEAD to check if a resource exists or to read its metadata Do\u2026 (optional) include headers in the request ensure idempotency i.e., request repeatability without side effects (especially for caching) Don\u2019t\u2026 include a body in the request include a body in the response Use PUT to both insert and update a stored resource \u00b6 Use PUT to: - add a new resource to a store, with a URI specified by the client. - update or replace an already stored resource. Do\u2026 include a body in the request Example A service-oriented REST API provides a store resource that allows its clients to persist their data as objects: PUT /users/1234/files/4b099410-0ed9-4719-b3e6-3a847bc3fade Warning The PUT request body may be different from the one received from a subsequent GET request because the resource might be partially immutable. See Stores must support conditional PUT requests for how to use headers to handle overloading PUT to both insert and update resources. Use PUT to update mutable resources \u00b6 Do\u2026 (optional) include a body in the request with the desired changes Use POST to create a new resource in a collection \u00b6 Example A client uses POST to request a new addition to a server-owned collection: POST /cities/new-york/museums/moma/exhibits Do\u2026 (optional) include a body in the request with the suggested initial state of the resource Use POST to execute controllers \u00b6 HTTP defines POST as unsafe and non-idempotent, which means that it may have unwanted side effects if repeated, similar to submitting a web form on an unresponsive site twice for one payment can lead to being charged twice. Using POST for controller resources is the natural choice, as gaining extra flexibility is worth losing some transparency and robustness. Do\u2026 (optional) include headers in the request (optional) include a body in the request Don\u2019t\u2026 Use POST to get, store, or delete resources, as specific HTTP methods for those actions already exist. Example A controller executed using POST to restart a router in the network: POST /routers/1234/restart Use DELETE to remove a resource from its parent collection or store \u00b6 Clients must be unable to find a resource after a DELETE request has been processed for it. Subsequent GET or HEAD requests on the resource must result in a 404 ( Not Found ) response. Example A user removes a document from a store: DELETE /users/1234/recipes/lasagna Don\u2019t\u2026 overload the role of DELETE by mapping it to a lesser action that leaves the resource, and its URI, available to clients Do\u2026 implement \u201csoft\u201d delete or other state-changing interaction via a controller resource and ask clients to use POST instead of DELETE Use OPTIONS to retrieve available interactions for a resource \u00b6 Example A user obtains resource metadata including the Allow header value via the OPTIONS request method: Allow: GET, PUT, DELETE","title":"Request Methods"},{"location":"request-methods/#request-methods","text":"","title":"Request Methods"},{"location":"request-methods/#definitions","text":"Each HTTP method is defined within the REST API resource model : GET retrieve a representation of a resource\u2019s state HEAD retrieve the metadata associated with the resource\u2019s state PUT add a new resource to a store or update a resource DELETE remove a resource from its parent POST create a new resource within a collection and execute controllers","title":"Definitions"},{"location":"request-methods/#rules","text":"","title":"Rules"},{"location":"request-methods/#dont-use-get-and-post-instead-of-other-request-methods","text":"Do\u2026 use HTTP methods as specified in this section Don\u2019t\u2026 change message intent and undermine the protocol\u2019s transparency compromise REST API design by misusing HTTP request methods because clients have limited HTTP vocabulary","title":"Don't use GET and POST instead of other request methods"},{"location":"request-methods/#use-get-to-retrieve-a-representation-of-a-resource","text":"Do\u2026 (optional) include headers in the request ensure idempotency i.e., repeatability without side effects (especially for caching) include a body in the response Don\u2019t\u2026 include a body in the request","title":"Use GET to retrieve a representation of a resource"},{"location":"request-methods/#use-head-to-retrieve-response-headers-without-a-body","text":"Use HEAD to check if a resource exists or to read its metadata Do\u2026 (optional) include headers in the request ensure idempotency i.e., request repeatability without side effects (especially for caching) Don\u2019t\u2026 include a body in the request include a body in the response","title":"Use HEAD to retrieve response headers without a body"},{"location":"request-methods/#use-put-to-both-insert-and-update-a-stored-resource","text":"Use PUT to: - add a new resource to a store, with a URI specified by the client. - update or replace an already stored resource. Do\u2026 include a body in the request Example A service-oriented REST API provides a store resource that allows its clients to persist their data as objects: PUT /users/1234/files/4b099410-0ed9-4719-b3e6-3a847bc3fade Warning The PUT request body may be different from the one received from a subsequent GET request because the resource might be partially immutable. See Stores must support conditional PUT requests for how to use headers to handle overloading PUT to both insert and update resources.","title":"Use PUT to both insert and update a stored resource"},{"location":"request-methods/#use-put-to-update-mutable-resources","text":"Do\u2026 (optional) include a body in the request with the desired changes","title":"Use PUT to update mutable resources"},{"location":"request-methods/#use-post-to-create-a-new-resource-in-a-collection","text":"Example A client uses POST to request a new addition to a server-owned collection: POST /cities/new-york/museums/moma/exhibits Do\u2026 (optional) include a body in the request with the suggested initial state of the resource","title":"Use POST to create a new resource in a collection"},{"location":"request-methods/#use-post-to-execute-controllers","text":"HTTP defines POST as unsafe and non-idempotent, which means that it may have unwanted side effects if repeated, similar to submitting a web form on an unresponsive site twice for one payment can lead to being charged twice. Using POST for controller resources is the natural choice, as gaining extra flexibility is worth losing some transparency and robustness. Do\u2026 (optional) include headers in the request (optional) include a body in the request Don\u2019t\u2026 Use POST to get, store, or delete resources, as specific HTTP methods for those actions already exist. Example A controller executed using POST to restart a router in the network: POST /routers/1234/restart","title":"Use POST to execute controllers"},{"location":"request-methods/#use-delete-to-remove-a-resource-from-its-parent-collection-or-store","text":"Clients must be unable to find a resource after a DELETE request has been processed for it. Subsequent GET or HEAD requests on the resource must result in a 404 ( Not Found ) response. Example A user removes a document from a store: DELETE /users/1234/recipes/lasagna Don\u2019t\u2026 overload the role of DELETE by mapping it to a lesser action that leaves the resource, and its URI, available to clients Do\u2026 implement \u201csoft\u201d delete or other state-changing interaction via a controller resource and ask clients to use POST instead of DELETE","title":"Use DELETE to remove a resource from its parent collection or store"},{"location":"request-methods/#use-options-to-retrieve-available-interactions-for-a-resource","text":"Example A user obtains resource metadata including the Allow header value via the OPTIONS request method: Allow: GET, PUT, DELETE","title":"Use OPTIONS to retrieve available interactions for a resource"},{"location":"resources/","text":"Resources \u00b6 Introduction \u00b6 Important You use resource modeling for REST API design just as you use a relational DB schema for a data model or a class hierarchy for OOP. Design first, then write URI paths. Each path segment in a URI belongs to a unique resource in the REST API resource model. This URI: http://api.subdomain.tld.com/cities/new-york/museums/moma implies that each of these URIs point to a resource: http://api.subdomain.tld.com http://api.subdomain.tld.com/cities http://api.subdomain.tld.com/cities/new-york http://api.subdomain.tld.com/cities/new-york/museums Document \u00b6 Definition A singular concept like an object instance or database record. A document\u2019s state representation typically includes both fields with values and links to other related resources. The document type is the conceptual base archetype of the other three other resource archetypes, which can be viewed as specializations of the document archetype. A document may have child resources that represent its specific subordinate concepts. Example A user retrieves information about New York, the New York Museum of Modern Art, and the May 2020 exhibit therein: GET http://api.subdomain.tld.com/cities/new-york GET http://api.subdomain.tld.com/cities/new-york/museums/moma GET http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may-2020 Use a document as the REST API root resource, a.k.a. the docroot . Success The docroot as the REST API entry point: http://api.subdomain.tld.com Collection \u00b6 Definition A server-managed directory of resources. A collection resource decides what resources to contain and their URIs. Clients may propose adding resources to a collection, but the collection decides to create a new resource, or not. Example A user retrieves lists of cities, New York museums, and exhibits in the New York Museum of Modern Art: GET http://api.subdomain.tld.com/cities GET http://api.subdomain.tld.com/cities/new-york/museums GET http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits Store \u00b6 Definition A client-managed resource repository. A store resource relies on the API client to add, retrieve or delete resources. Stores do not create resources or URIs by themselves. The client chooses the URI when putting the resource into the store. Example A user with ID 1234 inserts a document resource named moma (the Museum of Modern Art) in the store of visited museums in New York: PUT user/1234/cities/new-york/museums/moma Controller \u00b6 Definition A resource that models a procedural concept. Controller resources are like executable functions, with parameters and return values, inputs and outputs. Like a HTML forms in a web app, a REST API uses controllers for actions that don\u2019t map to standard CRUD methods (create, retrieve, update, and delete). Do\u2026 keep the controller name last in the URI path, without child resources Example Restart a router in the network: POST /routers/1234/restart","title":"Resources"},{"location":"resources/#resources","text":"","title":"Resources"},{"location":"resources/#introduction","text":"Important You use resource modeling for REST API design just as you use a relational DB schema for a data model or a class hierarchy for OOP. Design first, then write URI paths. Each path segment in a URI belongs to a unique resource in the REST API resource model. This URI: http://api.subdomain.tld.com/cities/new-york/museums/moma implies that each of these URIs point to a resource: http://api.subdomain.tld.com http://api.subdomain.tld.com/cities http://api.subdomain.tld.com/cities/new-york http://api.subdomain.tld.com/cities/new-york/museums","title":"Introduction"},{"location":"resources/#document","text":"Definition A singular concept like an object instance or database record. A document\u2019s state representation typically includes both fields with values and links to other related resources. The document type is the conceptual base archetype of the other three other resource archetypes, which can be viewed as specializations of the document archetype. A document may have child resources that represent its specific subordinate concepts. Example A user retrieves information about New York, the New York Museum of Modern Art, and the May 2020 exhibit therein: GET http://api.subdomain.tld.com/cities/new-york GET http://api.subdomain.tld.com/cities/new-york/museums/moma GET http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may-2020 Use a document as the REST API root resource, a.k.a. the docroot . Success The docroot as the REST API entry point: http://api.subdomain.tld.com","title":"Document"},{"location":"resources/#collection","text":"Definition A server-managed directory of resources. A collection resource decides what resources to contain and their URIs. Clients may propose adding resources to a collection, but the collection decides to create a new resource, or not. Example A user retrieves lists of cities, New York museums, and exhibits in the New York Museum of Modern Art: GET http://api.subdomain.tld.com/cities GET http://api.subdomain.tld.com/cities/new-york/museums GET http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits","title":"Collection"},{"location":"resources/#store","text":"Definition A client-managed resource repository. A store resource relies on the API client to add, retrieve or delete resources. Stores do not create resources or URIs by themselves. The client chooses the URI when putting the resource into the store. Example A user with ID 1234 inserts a document resource named moma (the Museum of Modern Art) in the store of visited museums in New York: PUT user/1234/cities/new-york/museums/moma","title":"Store"},{"location":"resources/#controller","text":"Definition A resource that models a procedural concept. Controller resources are like executable functions, with parameters and return values, inputs and outputs. Like a HTML forms in a web app, a REST API uses controllers for actions that don\u2019t map to standard CRUD methods (create, retrieve, update, and delete). Do\u2026 keep the controller name last in the URI path, without child resources Example Restart a router in the network: POST /routers/1234/restart","title":"Controller"},{"location":"response-status-codes/","text":"Response Status Codes \u00b6 Todo add content","title":"Response Status Codes"},{"location":"response-status-codes/#response-status-codes","text":"Todo add content","title":"Response Status Codes"},{"location":"uri-format/","text":"URI Format \u00b6 The RFC 3986 definition \u00b6 URI = scheme \"://\" authority \"/\" path [ \"?\" query ] [ \"#\" fragment ] Rules \u00b6 Form hierarchies with slash / as a separator, but don\u2019t end with a slash / \u00b6 Success http://api.subdomain.tld.com/cities/new-york/museums/moma Failure http://api.subdomain.tld.com/cities/new-york/museums/moma/ Use hyphens - to separate words, don\u2019t use underscores _ \u00b6 Success http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may-2020 Failure http://api.subdomain.tld.com/cities/newyork/museums/moma/exhibits/may2020 http://api.subdomain.tld.com/cities/new_york/museums/moma/exhibits/may_2020 Use lowercase letters \u00b6 Success http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may-2020 Failure http://api.subdomain.tld.com/CITIES/NewYork/museums/moma/exhibits/May2020 Avoid file extensions \u00b6 Don\u2019t use file extensions to specify format, use the Accept request header instead. The REST API is not a file system, and URIs are not file system paths. Success http://api.subdomain.tld.com/cities/new-york/museums Failure http://api.subdomain.tld.com/cities/new-york/museums.json Use consistent subdomain names \u00b6 The top-level domain and first subdomain names (e.g., subdomain.tld.com) of an API should identify its service owner. Use an api subdomain in the full domain name of your API \u00b6 Example http://api.subdomain.tld.com Use a developer subdomain in the full domain name of your developer portal \u00b6 Example http://developer.subdomain.tld.com","title":"URI Format"},{"location":"uri-format/#uri-format","text":"","title":"URI Format"},{"location":"uri-format/#the-rfc-3986-definition","text":"URI = scheme \"://\" authority \"/\" path [ \"?\" query ] [ \"#\" fragment ]","title":"The RFC 3986 definition"},{"location":"uri-format/#rules","text":"","title":"Rules"},{"location":"uri-format/#form-hierarchies-with-slash--as-a-separator-but-dont-end-with-a-slash-","text":"Success http://api.subdomain.tld.com/cities/new-york/museums/moma Failure http://api.subdomain.tld.com/cities/new-york/museums/moma/","title":"Form hierarchies with slash / as a separator, but don't end with a slash /"},{"location":"uri-format/#use-hyphens---to-separate-words-dont-use-underscores-_","text":"Success http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may-2020 Failure http://api.subdomain.tld.com/cities/newyork/museums/moma/exhibits/may2020 http://api.subdomain.tld.com/cities/new_york/museums/moma/exhibits/may_2020","title":"Use hyphens - to separate words, don't use underscores _"},{"location":"uri-format/#use-lowercase-letters","text":"Success http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may-2020 Failure http://api.subdomain.tld.com/CITIES/NewYork/museums/moma/exhibits/May2020","title":"Use lowercase letters"},{"location":"uri-format/#avoid-file-extensions","text":"Don\u2019t use file extensions to specify format, use the Accept request header instead. The REST API is not a file system, and URIs are not file system paths. Success http://api.subdomain.tld.com/cities/new-york/museums Failure http://api.subdomain.tld.com/cities/new-york/museums.json","title":"Avoid file extensions"},{"location":"uri-format/#use-consistent-subdomain-names","text":"The top-level domain and first subdomain names (e.g., subdomain.tld.com) of an API should identify its service owner.","title":"Use consistent subdomain names"},{"location":"uri-format/#use-an-api-subdomain-in-the-full-domain-name-of-your-api","text":"Example http://api.subdomain.tld.com","title":"Use an api subdomain in the full domain name of your API"},{"location":"uri-format/#use-a-developer-subdomain-in-the-full-domain-name-of-your-developer-portal","text":"Example http://developer.subdomain.tld.com","title":"Use a developer subdomain in the full domain name of your developer portal"},{"location":"uri-paths/","text":"URI Paths \u00b6 As a general rule, any mentions of noun or verb also implies noun phrases and verb phrases. Rules \u00b6 Use a singular noun for document name path segments \u00b6 Success The URI for a single animal document uses a singular noun: http://api.subdomain.tld.com/continents/africa/animals/elephant Use a plural noun for collection name path segments \u00b6 A collection\u2019s name should be chosen to reflect what it uniformly contains. Success A collection uses a plural noun for contained resources: http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits Use a plural noun for store name path segments \u00b6 Success The URI for a store of music playlists may use the plural noun form as follows: http://api.subdomain.tld.com/artists/mikemassedotcom/playlists Use a verb for controller name path segments \u00b6 Like computer program functions, the URI name for a controller resource should indicate its action. Success http://api.subdomain.tld.com/users/john-smith/activate http://api.subdomain.tld.com/dbs/postgres/reindex http://api.subdomain.tld.com/routers/1234/restart Variable path segments may be substituted with identity-based values \u00b6 URI path segments can be: - static: fixed names that may be chosen by the REST API author - dynamic: automatically inserted identifier that ensures URI uniqueness The REST API or its clients must substitute variables in the URI template with a numeric or alphanumeric identifier before resolution. Success This template has three variables ( cityId , museumId , exhibitId ): http://api.subdomain.tld.com/cities/{cityId}/museums/{museumId}/exhibits/{exhibitId} and becomes, after substitution: http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may_2020 REST API clients must use URIs as the only relevant resource identifiers. With URIs as the only IDs, the REST API backend implementation is free to evolve without impact on existing clients. If backend system identifiers, such as database IDs, appear in URI paths, they must be irrelevant to client code. Avoid CRUD function names in URIs \u00b6 Don\u2019t\u2026 use URIs to indicate that a CRUD function is performed GET /deleteUser?id=1234 GET /deleteUser/1234 DELETE /deleteUser/1234 POST /users/1234/delete Do\u2026 use URIs to uniquely identify resources named resources as described in the rules above use HTTP request methods to indicate which CRUD function is performed DELETE /users/1234","title":"URI Paths"},{"location":"uri-paths/#uri-paths","text":"As a general rule, any mentions of noun or verb also implies noun phrases and verb phrases.","title":"URI Paths"},{"location":"uri-paths/#rules","text":"","title":"Rules"},{"location":"uri-paths/#use-a-singular-noun-for-document-name-path-segments","text":"Success The URI for a single animal document uses a singular noun: http://api.subdomain.tld.com/continents/africa/animals/elephant","title":"Use a singular noun for document name path segments"},{"location":"uri-paths/#use-a-plural-noun-for-collection-name-path-segments","text":"A collection\u2019s name should be chosen to reflect what it uniformly contains. Success A collection uses a plural noun for contained resources: http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits","title":"Use a plural noun for collection name path segments"},{"location":"uri-paths/#use-a-plural-noun-for-store-name-path-segments","text":"Success The URI for a store of music playlists may use the plural noun form as follows: http://api.subdomain.tld.com/artists/mikemassedotcom/playlists","title":"Use a plural noun for store name path segments"},{"location":"uri-paths/#use-a-verb-for-controller-name-path-segments","text":"Like computer program functions, the URI name for a controller resource should indicate its action. Success http://api.subdomain.tld.com/users/john-smith/activate http://api.subdomain.tld.com/dbs/postgres/reindex http://api.subdomain.tld.com/routers/1234/restart","title":"Use a verb for controller name path segments"},{"location":"uri-paths/#variable-path-segments-may-be-substituted-with-identity-based-values","text":"URI path segments can be: - static: fixed names that may be chosen by the REST API author - dynamic: automatically inserted identifier that ensures URI uniqueness The REST API or its clients must substitute variables in the URI template with a numeric or alphanumeric identifier before resolution. Success This template has three variables ( cityId , museumId , exhibitId ): http://api.subdomain.tld.com/cities/{cityId}/museums/{museumId}/exhibits/{exhibitId} and becomes, after substitution: http://api.subdomain.tld.com/cities/new-york/museums/moma/exhibits/may_2020 REST API clients must use URIs as the only relevant resource identifiers. With URIs as the only IDs, the REST API backend implementation is free to evolve without impact on existing clients. If backend system identifiers, such as database IDs, appear in URI paths, they must be irrelevant to client code.","title":"Variable path segments may be substituted with identity-based values"},{"location":"uri-paths/#avoid-crud-function-names-in-uris","text":"Don\u2019t\u2026 use URIs to indicate that a CRUD function is performed GET /deleteUser?id=1234 GET /deleteUser/1234 DELETE /deleteUser/1234 POST /users/1234/delete Do\u2026 use URIs to uniquely identify resources named resources as described in the rules above use HTTP request methods to indicate which CRUD function is performed DELETE /users/1234","title":"Avoid CRUD function names in URIs"},{"location":"uri-queries/","text":"URI Queries \u00b6 Introduction \u00b6 RFC 3986 states that a URI\u2019s optional query comes after the path and before the optional fragment: URI = scheme \"://\" authority \"/\" path [ \"?\" query ] [ \"#\" fragment ] As a component of a URI, the query contributes to the unique identification of a resource. Example The URI of a controller resource that sends an SMS message with a text value of hello : http://api.college.tld.com/students/morgan/send-sms http://api.college.tld.com/students/morgan/send-sms?text=hello The query component contains a set of parameters to be interpreted as a variation of the resource. These two resources are not the same, but are very closely related. The query component can provide clients with additional interaction capabilities such as ad hoc searching and filtering. Thus, unlike the other elements of a URI, the query part may be transparent to a REST API\u2019s client. The entirety of a resource\u2019s URI should be treated opaquely by basic network-based intermediaries such as HTTP caches. Caches \u00b6 Caches must not vary their behavior based on the presence or absence of a query in a given URI. Do\u2026 use headers to direct a cache intermediary\u2019s behavior Don\u2019t\u2026 use queries to direct a cache intermediary\u2019s behavior exclude response messages from caches based solely upon the presence of a query in the requested URI Rules \u00b6 Use the query component of a URI to filter collections or stores \u00b6 A URI\u2019s query component is a natural fit for supplying search criteria to a collection or store. Example The response would contain a listing of all the cities in the collection: GET /cities The response would contain a filtered list of all the cities in the collection with a Nevada value for state : GET /cities?state=Nevada Use either the query component of a URI or a controller to paginate collection or store results \u00b6 Use the query component to paginate collection and store results with the following parameters: - pageSize: maximum number of contained elements desired in the response - pageStartIndex: the zero-based index of the first element desired in the response Example GET /users?pageSize=50&pageStartIndex=200 For complex client pagination or filtering requirements, which exceeds the simple formatting capabilities of the query part, design a controller resource associated with a collection or store. This allows for custom range types and special sort orders to be easily specified in the client request message body. Be careful to ensure that the controller\u2019s cacheable results are marked accordingly. Example This controller may accept more complex inputs via a request\u2019s entity body instead of the URI\u2019s query part: POST /cities/search","title":"URI Queries"},{"location":"uri-queries/#uri-queries","text":"","title":"URI Queries"},{"location":"uri-queries/#introduction","text":"RFC 3986 states that a URI\u2019s optional query comes after the path and before the optional fragment: URI = scheme \"://\" authority \"/\" path [ \"?\" query ] [ \"#\" fragment ] As a component of a URI, the query contributes to the unique identification of a resource. Example The URI of a controller resource that sends an SMS message with a text value of hello : http://api.college.tld.com/students/morgan/send-sms http://api.college.tld.com/students/morgan/send-sms?text=hello The query component contains a set of parameters to be interpreted as a variation of the resource. These two resources are not the same, but are very closely related. The query component can provide clients with additional interaction capabilities such as ad hoc searching and filtering. Thus, unlike the other elements of a URI, the query part may be transparent to a REST API\u2019s client. The entirety of a resource\u2019s URI should be treated opaquely by basic network-based intermediaries such as HTTP caches.","title":"Introduction"},{"location":"uri-queries/#caches","text":"Caches must not vary their behavior based on the presence or absence of a query in a given URI. Do\u2026 use headers to direct a cache intermediary\u2019s behavior Don\u2019t\u2026 use queries to direct a cache intermediary\u2019s behavior exclude response messages from caches based solely upon the presence of a query in the requested URI","title":"Caches"},{"location":"uri-queries/#rules","text":"","title":"Rules"},{"location":"uri-queries/#use-the-query-component-of-a-uri-to-filter-collections-or-stores","text":"A URI\u2019s query component is a natural fit for supplying search criteria to a collection or store. Example The response would contain a listing of all the cities in the collection: GET /cities The response would contain a filtered list of all the cities in the collection with a Nevada value for state : GET /cities?state=Nevada","title":"Use the query component of a URI to filter collections or stores"},{"location":"uri-queries/#use-either-the-query-component-of-a-uri-or-a-controller-to-paginate-collection-or-store-results","text":"Use the query component to paginate collection and store results with the following parameters: - pageSize: maximum number of contained elements desired in the response - pageStartIndex: the zero-based index of the first element desired in the response Example GET /users?pageSize=50&pageStartIndex=200 For complex client pagination or filtering requirements, which exceeds the simple formatting capabilities of the query part, design a controller resource associated with a collection or store. This allows for custom range types and special sort orders to be easily specified in the client request message body. Be careful to ensure that the controller\u2019s cacheable results are marked accordingly. Example This controller may accept more complex inputs via a request\u2019s entity body instead of the URI\u2019s query part: POST /cities/search","title":"Use either the query component of a URI or a controller to paginate collection or store results"}]}